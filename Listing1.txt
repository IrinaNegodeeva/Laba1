
	GET main.s

;Директива PRESERVE8 Указывает, что текущий файл требует или сохраняет восьмибайтовое выранивание стека
    PRESERVE8
		
;Директива THUMB инструктирует ассемблер интерпретировать последующие инструкции, 
;как инструкции Thumb используя синтаксис UAL.
    THUMB	

    AREA CONSTANT_FLASH, DATA, READONLY
        
masive          DCB 1, 1, 4, -2, -6, 0, 3, 2, 1, 3
masive_size     DCB masive_size-masive
;masive1         DCB 1, 1, 4, -3, 2, 0, 3, 2, 1, 3, 2
;masive_size1    DCB masive_size1-masive1
;masive2         DCB 1, 1, 4, -3, 2, 0, 3, 2, 1, 3, 3, 5
;masive_size2    DCB masive_size2-masive2
;masive3         DCB 1, 1, 4, -3, 2, 0, 3, 2, 1, 3, 5, 6, 1, 1, 4, -3, 2, 0, 3, 2, 1, 3, 5, 6, 1
;masive_size3    DCB masive_size3-masive3

; Объявляем сегмент переменных
	AREA VERIABLE_RAM, DATA, READWRITE

res SPACE 0x01
res1 SPACE 0x01

;Объявляем стартовый сегмент кода 
	AREA RESET, CODE, READONLY	

; Таблица векторов прерываний
    DCD STACK_TOP 	   ; Указатель на вершину стека
    DCD startup		   ; Вектор сброса

;Точка входа
    ENTRY


;Startup код
startup		PROC       ; Начало startup кода 
	                   ; Инициализация МК    
; Вызов подпрограмм
    PUSH {R0-R12}          ; Сохранение регистров в памяти  
; Подготовка регистров
    LDR R0, =masive        ; Указатель на адрес массива
    LDR R1, =masive_size   ; Указатель на адрес размера массива 
    LDRB R1, [R1]          ; В R1 значение размера массива (число)
    
    BL var_5               ; Вызов ПП, вызывающей остальные ПП
    POP {R0-R12}           ; Возврат регистров
    
      
	B .
	ENDP	               ; Конец программы           
 
var_5       PROC           ; ПП, вызывающая остальные ПП
    PUSH {LR}              ; Сохранение адреса возврата
; Вызов подпрограмм
    PUSH {R0-R12}          ; Сохранение регистров в памяти      
; Переход в подпрограмму avg_calc для расчета средн. арифм.    
    BL avg_calc            ; Переход к ПП для расчета средн. арифм.
; Обработка результата
    LDR R7, =res           ; Запись адреса переменной "res" в R7
    STR R0, [R7]           ; Сохранить содержимое регистра R0 в памяти по адресу в регистре R7  
; Восстановление контекста
    POP {R0-R12}           ; Возврат регистров
 
  
; Вызов подпрограмм
    PUSH {R0-R12}          ; Сохранение регистров в памяти      
; Переход в подпрограмму find_min для поиска минимального значения   
    BL find_min            ; Переход к ПП для поиска минимального значения
; Обработка результатов
    LDR R6, =res1          ; Запись адреса переменной "res1" в R6
    STR R0, [R6]           ; Сохранить содержимое регистра R0 в памяти по адресу в регистре R6  
; Восстановление контекста
    POP {R0-R12}           ; Возврат регистров

    POP {LR}               ; Возврат адреса для выхода из ПП
    BX LR

;******************************************************************************
avg_calc    PROC           ; ПП для расчета средн. арифм.
 
    MOV R2, #NULL          ; R2 = "i" = 0 - элемент массива
    MOV R3, #NULL          ; R3 = 0 - обнуление регистра R3
    MOV R4, #NULL          ; R4 = "sn" - 0 - сумма отрицательных элементов
    MOV R5, #NULL          ; R5 = "n" = 0 - кол-во отрицательных элементов
       
CVTR                       ; Метка CVTR
    CMP R2, R1             ; Проверка "i" с "masive_size"
    BLT CAJ                ; Если i < masive_size, переход в "CAJ"
    B SRZN                 ; Безусловный переход в "SRZN" - выполняется только, когда не произошел переход в "CAJ"
    
CAJ                        ; Метка CAJ
; Запись в регистр "R3" значения по адресу сохранённом в "R2" 
    LDRB R3, [R0, R2]      ; R3 = mas[i] 
    SXTB R3, R3            ; Расширение знака
    CMP R3, #NULL          ; Сравнить mas[i] с 0
    BLT JNT                ; Если mas[i] < 0, то переходим в JNT
    B OUTXX                ; Безусловный переход в OUTXX
    
JNT                        ; Метка JNT
    SXTB R4, R4            ; Расширение знака
    ADD R4, R3             ; sn = sn + mas[i]
    ADD R5, #ONE           ; n = n + 1

OUTXX                      ; Метка OUTXX
    ADD R2, #ONE           ; i = i + 1

    B CVTR                 ; Переход в начало подпрограммы
    
; Среднее арифметическое
    CMP R5, #NULL          ; Сравнение n с нулем
    BNE SRZN               ; Если не равно нулю, то переход в SRZN 
    B OUTEX                ; Иначе переход в OUTEX
SRZN                       ; Метка SRZN
    SDIV R4, R4, R5        ; Среднее арифм.
       
; Записать значение результата в регистр "R0"
OUTEX                      ; Метка OUTEX
    SXTB R0, R0            ; Расширение знака
    MOV R0, R4             ; Запись R4 в R0

    BX LR                  ; Возвращение по адресу, сохраненном в LR
    ENDP                   ; Конец подпрограммы
;------------------------------------------------------------------------------
find_min    PROC           ; ПП для поиска минимального значения

    MOV R2, #NULL          ; R2 = "i" = 0 - элемент массива
    MOV R3, #NULL          ; R3 = 0 - обнуление регистра R3   
    MOV R4, #NULL          ; R4 = "nm" = 0 - наименьший элемент
    
KYTR                       ; Метка KYTR
    CMP R2, R1             ; Проверка "i" c "masive_size"
    BLT CAT                ; Если i < MAX_size, переход в "CAT"
    B OUTEXX               ; Безусловный переход в "OUTEXX" - выполняется только, когда не произошел переход в "CAT"
    
CAT                        ; Метка CAT
; Запись в регистр "R3" значения по адресу сохранённом в "R2" 
    LDRB R3, [R0, R2]      ; R3 = mas[i] 
    SXTB R3, R3            ; Расширение знака
    CMP R3, #NULL          ; Сравнить mas[i] с 0
    BLT LKJ                ; Если mas[i] < 0, то переходим в LKJ
    B OUTXXX               ; Безусловный переход в OUTXXX
        
LKJ                        ; Метка LKJ
    CMP R3, R4             ; Сравнение mas[i] с nm
    BLE SRAW               ; Если mas[i] < nm, то переход в SRAW
    B OUTXXX               ; Иначе переход в OUTXXX
    
SRAW                       ; Метка SRAW
    MOV R4, R3             ; Запись R4 = R3, присвоили R4 Титул элемента с минимальным значением

OUTXXX                     ; Метка OUTXX
    ADD R2, #ONE           ; i = i + 1
    B KYTR                 ; Переход в начало подпрограммы

OUTEXX                     ; Метка OUTEXX
    SXTB R0, R0
    MOV R0, R4             ; Запись R4 в R0

    BX LR                  ; Возвращение по адресу, сохраненном в LR
    ENDP                   ; Конец ПП 
;-------------------------------------------------------------------------------        

   
    END		               ; Конец файла